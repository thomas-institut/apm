<?php

namespace ThomasInstitut\DataCache;

use InvalidArgumentException;
use Psr\Log\LoggerAwareInterface;
use Psr\Log\LoggerAwareTrait;
use Psr\Log\NullLogger;
use RuntimeException;

/**
 * A DataCache that stores its data in a directory with
 * one file per cache entry.
 *
 * This cache does not implement TTL, the cache can be cleaned
 * externally simply by removing files from the directory.
 */
class DirectoryDataCache implements DataCache, LoggerAwareInterface
{
    use LoggerAwareTrait;

    const string NoExpirationString = 'NON_EXP';

    private string $cachePath;
    private string $cacheName;
    private string $fileExtension;
    private int $defaultTtl;


    /**
     * Constructs a directory data cache using the given path
     *
     * @param string $directoryPath
     * @param string $cacheName will be used as prefix for the files generated by the cache
     * @param string $fileExtension
     */
    public function __construct(string $directoryPath, string $cacheName, string $fileExtension = 'txt')
    {
        $this->cachePath = realpath($directoryPath);
        $this->cacheName = $cacheName;
        $this->fileExtension = $fileExtension;
        $this->defaultTtl = 0;
        $this->logger = new NullLogger();
    }

    /**
     * @inheritDoc
     */
    public function get(string $key): string
    {
        $filePath = $this->getNonExpiredFileNameForKey($key);
        if ($filePath === null) {
            throw new KeyNotInCacheException();
        }
        $value = file_get_contents($filePath);
        if ($value === false) {
            throw new RuntimeException("Could not read cache file '$key'");
        }
        return $value;
    }

    private function getNonExpiredFileNameForKey(string $key): ?string
    {
        if (!$this->isValidKey($key)) {
            return null;
        }
        $filePaths = glob($this->getFilePathForKey($key, '*'));
        if (count($filePaths) === 0) {
            return null;
        }
        $now = time();
        foreach ($filePaths as $filePath) {
            [, $expirationTimestamp] = $this->getKeyAndExpirationTimeFromFilePath($filePath);
            if ($expirationTimestamp === 0 || $expirationTimestamp > $now) {
                return $filePath;
            }
        }
        return null;
    }

    private function getFilePathForKey(string $key, string $expires): string
    {
        return "$this->cachePath/$this->cacheName-$key-$expires.$this->fileExtension";
    }

    private function getKeyAndExpirationTimeFromFilePath(string $filePath): array
    {
        $fileName = preg_replace("/\.$this->fileExtension$/", '', basename($filePath));
        [, $key, $expires] = explode('-', $fileName);
        $expirationTimestamp = $expires === self::NoExpirationString ? 0 : intval($expires);
        return [$key, $expirationTimestamp];
    }

    /**
     * @inheritDoc
     */
    public function getRemainingTtl(string $key): int
    {
        return -1;
    }

    /**
     * @inheritDoc
     */
    public function isInCache(string $key): bool
    {
        return $this->getNonExpiredFileNameForKey($key) !== null;
    }

    /**
     * @inheritDoc
     */
    public function set(string $key, string $value, int $ttl = -1): void
    {
        if (!$this->isValidKey($key)) {
            throw new InvalidArgumentException("Cache key '$key' is not a valid key for this cache");
        }
        $this->delete($key);

        if ($ttl < 0) {
            $ttl = $this->defaultTtl;
        }
        $expires = self::NoExpirationString;
        if ($ttl > 0) {
            $expires = strval(time() + $ttl);
        }

        file_put_contents($this->getFilePathForKey($key, $expires), $value);

    }

    /**
     * @inheritDoc
     */
    public function delete(string $key): void
    {
        if (!$this->isValidKey($key)) {
            return;
        }
        $filePaths = glob($this->getFilePathForKey($key, '*'));
        foreach ($filePaths as $filePath) {
            unlink($filePath);
        }
    }

    private function isValidKey(string $key): bool
    {
        $characters = ['*', '/', '-'];
        foreach ($characters as $char) {
            if (str_contains($key, $char)) {
                return false;
            }
        }
        return true;
    }

    /**
     * @inheritDoc
     */
    public function setDefaultTtl(int $ttl): void
    {
        if ($ttl >= 0) {
            $this->defaultTtl = $ttl;
        }
    }

    /**
     * @inheritDoc
     */
    public function flush(): void
    {
        $files = glob($this->getFilePathForKey('*', '*'));
        foreach ($files as $file) {
            unlink($file);
        }
        $this->logger->info(sprintf('Flushed directory cache %s, %d files deleted"', $this->cacheName, count($files)));
    }

    /**
     * @inheritDoc
     */
    public function clean(): void
    {
        $filePaths = glob($this->getFilePathForKey('*', '*'));
        $now = time();
        $countDeleted = 0;
        foreach ($filePaths as $filePath) {
            [, $expirationTimestamp] = $this->getKeyAndExpirationTimeFromFilePath($filePath);
            if ($expirationTimestamp !== 0 && $expirationTimestamp < $now) {
                $countDeleted++;
                unlink($filePath);
            }
        }
        $this->logger->info(sprintf('Cleaned directory cache %s, %d files deleted"', $this->cacheName, $countDeleted));
    }
}