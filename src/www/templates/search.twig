{% extends "base.twig" %}

{% block title %}Search{% endblock %}

{% block finalBodyJS %}
    <script>
      $(() => {

        // Get selectors for catching user input
        let keywordBox = $("#keywordBox")
        let transcriptBox = $("#transcriptBox")
        let transcriberBox = $("#transcriberBox")
        let radiusSlider = $("#radiusSlider")
        let lemmatizeBox = $("#lemmatize")

        // Key-Up functions for all boxes
        keywordBox.on("keyup", delay(function () {
          search()
        }, 300))

        transcriptBox.on("click", () => {
          getInput ('titles')
        })

        transcriptBox.on("input", delay(function () {
          let userText = $(this).val();
          if (userText === "") {
            search()
          }
          else {
          $("#titleList").find("option").each(function() {
            if ($(this).val() === userText) {
              search()
            }
          })
        }}, 50))

        transcriberBox.on("click", () => {
          getInput ('transcribers')
        })

        transcriberBox.on("input", delay(function () {
          let userText = $(this).val();
          if (userText === "") {
            search()
          }
          else {
          $("#transcriberList").find("option").each(function() {
            if ($(this).val() === userText) {
              search()
            }
          })
        }}, 50))

        radiusSlider.on("change", () => {
          search()
        })

        lemmatizeBox.on("change", () => {
          search()
        })
      })

      // Function to delay keyup and sliderchange event to avoid unnecessary queries for unfinished user input â€“
      // i. e. if quickly typed "natura", search only for "natura" and not for "n", "na", "nat",...
      function delay (callback, ms) {
        let timer = 0;
        return function() {
          let context = this, args = arguments;
          clearTimeout(timer);
          timer = setTimeout(function () {
            callback.apply(context, args);
          }, ms || 0);
        };
      }

      // Function to get list of indexed values, i. e. titles or transcribers, via an API call
      function getInput (category) {

        // Get queried category
        if (category === 'titles') {

          // Make API request
          $.post("{{ url_for('search.titles') }}").done((apiResponse) => {

            // Get titleList selector and clear the list
            let titleList = $("#titleList")
            titleList.empty()

            // Catch errors
            if (apiResponse.status !== 'OK') {
              console.log(`Error in query for titles!`)
              if (apiResponse.errorData !== undefined) {
                console.log(apiResponse.errorData)
              }
              errorMessage
                .html('Error while getting doc list, please report to technical administrators.')
                .removeClass('text-error')
              return
            }
            console.log(apiResponse)

            // Get titles from apiResponse
            let titles = apiResponse[category]

            // Fill datatable with title names
            titles.forEach(function (item) {titleList.append(`<option>${item}</option>`)})

          })
        }
        else if (category === 'transcribers') {

          // Do exactly the same as before, but with transcribers instead of titles - by time this could be merged into one general function
          $.post("{{ url_for('search.transcribers') }}").done((apiResponse) => {

            let transList = $("#transcriberList")
            transList.empty()

            if (apiResponse.status !== 'OK') {
              console.log(`Error in query for transcribers!`)
              if (apiResponse.errorData !== undefined) {
                console.log(apiResponse.errorData)
              }
              errorMessage
                .html('Error while getting transcribers list, please report to technical administrators.')
                .removeClass('text-error')
              return
            }
            console.log(apiResponse)

            let transcribers = apiResponse[category]

            transcribers.forEach(function (item) {transList.append(`<option>${item}</option>`)})

          })
        }
      }

      // Function to start search process via API call
      function search () {

        // Get selectors for user input and get input
        let keywordBox = $("#keywordBox")
        let transcriptBox = $("#transcriptBox")
        let transcriberBox = $("#transcriberBox")
        let radiusSlider = $("#radiusSlider")
        let lemmatizeBox = $("#lemmatize")
        let spinner = $("#spinner")

        let searchText = keywordBox.val()
        let title = transcriptBox.val();
        let transcriber = transcriberBox.val();
        let radius = radiusSlider.val()
        let lemmatize = lemmatizeBox.prop('checked')

        // Signal search process
        spinner.html(`<div class="spinner-border" role="status"></div>`)

        // Send all user input to ApiSearch (via routing in index.php) and print returned matches
        $.post("{{ url_for('search.keyword') }}", { searchText: searchText, radius: radius, title: title, transcriber: transcriber, lemmatize: lemmatize })
          .done((apiResponse) => {

            // Catch errors
            if (apiResponse.status !== 'OK') {
              console.log(`Error in query`)
              if (apiResponse.errorData !== undefined) {
                console.log(apiResponse.errorData)
              }
              errorMessage
                .html('Error while searching, please report to technical administrators.')
                .removeClass('text-error')
              return
            }

            console.log(apiResponse)

            // Call displayResults-function
            spinner.empty()
            displayResults(apiResponse)

      }).fail((status) => {
        console.log(status)
        spinner.empty()
          errorMessage
          .html('Search is currently not available. Please try again later.')
          .removeClass('text-error')
      })
      }

      // Function to collect and display the search results in readable form
      function displayResults (results) {

        // Get selectors for displaying results
        let errorMessage = $("#error_message")
        let numMatchesTable = $("#numMatchesTable")
        let resultsTableB = $("#resultsTable tbody")
        let resultsTableH = $("#resultsTable thead")

        // Empty tables and divs
        numMatchesTable.empty()
        resultsTableH.empty()
        resultsTableB.empty()
        errorMessage.empty()

        // Get instance of ApmUrlGenerator for creating links to matching docs
        let urlGenerator = new ApmUrlGenerator('{{baseurl}}')

        // Get column data of search result
        let data = results['data']

        // Count matches
        let num_columns = data.length
        let num_passages = results['num_passages_total']
        let num_docs = getNumDocs(data, num_columns)

        // If there are no matches, display this to the user and empty the table
        if (num_columns === 0) {
          resultsTableB.empty()
          numMatchesTable
            .html(`<tr><td>Matched Documents: &nbsp</td><td>0</td><tr><td>Matched Passages:</td><td>0</td>`)
            .addClass('text-warning')
        }

        // If there is exactly one matched column, display it with exact information
        else if (num_columns === 1 && num_passages === 1) {

          // Display number of matches
          numMatchesTable
            .html(`<tr><td>Matched Documents: &nbsp</td><td>${num_docs}</td><tr><td>Matched Passages:</td><td>${num_passages}</td>`)
            .removeClass('text-warning')

          // Make table head
          resultsTableH.empty()
          resultsTableH.append(`<tr><th>Title</th><th>Matched Passage</th><th>Page</th><th>Column</th><th>Transcriber</th><th>Link</th></tr>`)

          // Collect relevant data from API response
          let title = data[0]['title']
          let page = data[0]['page']
          let column = data[0]['column']
          let transcriber = data[0]['transcriber']
          let passages = data[0]['passage_tokenized']
          let tokens_matched = data[0]['tokens_matched']
          let docID = data[0]['docID']

          // Get link for matched column
          let url = urlGenerator.sitePageView(docID, page, column)
          let link = getLink(url)

          // Convert the tokens_matched in their context into a single string and highlight the tokens_matched
          let passages_string = ""

          for (let j = 0; j < passages.length; j++) {
            passages_string = highlight(passages[j], tokens_matched[j])
            passages_string = removeBlanks(passages_string)

            // Fill table with results
            resultsTableB.empty()
            resultsTableB.append(
              `<tr><td>${title}</td><td align="justify">${passages_string}</td><td>${page}</td><td>${column}</td><td>${transcriber}</td><td>${link}</td></tr>`)
          }
        }

        // If there is more than one matched column, display them all with exact information
        else {

          // Display number of matches
          numMatchesTable
            .html(`<tr><td>Matched Documents: &nbsp</td><td>${num_docs}</td><tr><td>Matched Passages:</td><td>${num_passages}</td>`)
            .removeClass('text-warning')

          // Make table head
          resultsTableH.empty()
          resultsTableH.append(`<tr><th>Title</th><th>Matched Passage</th><th>Page</th><th>Column</th><th>Transcriber</th><th>Link</th></tr>`)
          resultsTableB.empty()

          // Make variable for storing title of preceeding column in the dataset to display only ONE title,
          // if there are plenty matched columns of the same document
          let prec_title = " "

          // Write all matches into the results table
          for (let i = 0; i < num_columns; i++) {

            // Collect relevant Data from API response
            let title = data[i]['title']
            let page = data[i]['page']
            let column = data[i]['column']
            let transcriber = data[i]['transcriber']
            let tokens_matched = data[i]['tokens_matched']
            let passages = data[i]['passage_tokenized']
            let docID = data[i]['docID']

            // Get link for matched column
            let url = urlGenerator.sitePageView(docID, page, column)
            let link = getLink(url)

            // Convert all occurrences of the keyword in their contexts into a single string and highlight the tokens_matched
            let passages_string = ""

            for (let j = 0; j < passages.length; j++) {

              passages_string = highlight(passages[j], tokens_matched[j])
              passages_string = removeBlanks(passages_string)

              // Fill table with results
              if (title === prec_title) {
                resultsTableB.append(
                  `<tr><td></td><td align="justify">${passages_string}</td><td>${page}</td><td>${column}</td><td>${transcriber}</td><td>${link}</td></tr>`)
              }
              else {
                resultsTableB.append(
                  `<tr><td>${title}</td><td align="justify">${passages_string}</td><td>${page}</td><td>${column}</td><td>${transcriber}</td><td>${link}</td></tr>`)
                prec_title = title
              }
            }
          }
        }
      }

      // Function to add a link to a string in html
      function getLink (url) {
        return `<a class="fas fa-external-link-alt" target="_blank" href=${url} </a>`;
        // return `${string} &nbsp &nbsp &nbsp <a class="fas fa-external-link-alt" target="_blank" href=${url} </a>`;
      }

      // Function to calculate total number of matched documents
      function getNumDocs (data, numColumns) {

        let numDocs = 0
        let prevTitle = ""

        for (i=0; i<numColumns; i++) {
          let title = data[i]['title']
          if (title !== prevTitle) {
            numDocs = numDocs + 1
          }
          prevTitle = title
        }
        return numDocs
      }

      // Function to highlight the searched keyword in its context
      function highlight (passage, tokens_matched) {

        // Returned variable holding string with highlighted tokens_matched in it
        let passage_highlighted = ""

        // Convert array to string with boldened tokens_matched

        for (i=0; i<passage.length; i++) {
          // Get current word of passage-array
          let token = passage[i]
          // Bolden token, if it is one of the tokens_matched
          if (tokens_matched.indexOf(token) !== -1) {
            token = token.bold()
          }
          // Append token to returned string
          passage_highlighted = passage_highlighted + token + " "
        }
        return passage_highlighted
      }

      function indexOfAll(text, token) {
        var i = text.indexOf(token),
                indexes = [];
        while (i !== -1) {
          indexes.push(i);
          i = text.indexOf(token, ++i);
        }
        return indexes;
      }

      function removeBlanks (text) {
        text = text.replaceAll(" .", ".")
        text = text.replaceAll(" ,", ",")
        text = text.replaceAll(" :", ":")
        text = text.replaceAll("[ ", "[")
        text = text.replaceAll(" ]", "]")

        return text
      }

    </script>
{%  endblock %}

{% block content %}
    <h1> Search </h1>
<table class="dataTable" id="searchTable">
    <tr><td><b>Keywords</b></td><td><b>Transcript</b></td><td><b>Transcriber</b></td><td><b>Radius</b></td><td align="center"><b>Lemmatization</b></td></tr>

    <tr>
        <td>
            <div id="search_form">
            <label for="keywordBox"></label>
            <input type="text" id="keywordBox" placeholder="">
            </div>
        </td>
        <td>
            <div id="doc_form">
                <label for="transcriptBox"></label>
                <input list="titleList" id="transcriptBox" placeholder="">
                <datalist id="titleList">
                </datalist>
            </div>
        </td>
        <td>
            <div id="transcriber_form">
                <label for="transcriberBox"></label>
                <input list="transcriberList" id="transcriberBox" placeholder="">
                <datalist id="transcriberList">
                </datalist>
            </div>
        </td>
        <td>
            <form>
                <label for="radiusSlider"></label>
                <input type="range" id="radiusSlider" name="radiusSlider" min="3" max="40" value="12">
            </form>
        </td>
      <td align="center">
        <div>
          <input type="checkbox" id="lemmatize" name="lemmatize">
        </div>
      </td>
    </tr>
</table>

  <div id="spinner" class="text-muted" style="margin: 20px; text-align: center;">
    <br><br><br>
  </div>

    <br>
    <div id="error_message"></div>

    <br>
    <table class="doctable" id="numMatchesTable">
    </table>
    <br>

    <br>
    <table class="doctable dataTable no-footer" id="resultsTable">
        <thead></thead>
        <tbody></tbody>
    </table>

    <p></p>

{% endblock %}



