{% extends "base.twig" %}

{% block title %}Search{% endblock %}

{% block finalBodyJS %}
    <script>
      $(() => {

        // Get selectors for catching user input
        let keywordBox = $("#keywordBox")
        let transcriptBox = $("#transcriptBox")
        let transcriberBox = $("#transcriberBox")
        let radiusSlider = $("#radiusSlider")
        let lemmatizeBox = $("#lemmatize")

        // Key-Up functions for all boxes
        keywordBox.on("keyup", delay(function () {
          search()
        }, 300))

        transcriptBox.on("click", () => {
          getInput ('titles')
        })

        transcriptBox.on("input", delay(function () {
          let userText = $(this).val();
          if (userText === "") {
            search()
          }
          else {
          $("#titleList").find("option").each(function() {
            if ($(this).val() === userText) {
              search()
            }
          })
        }}, 50))

        transcriberBox.on("click", () => {
          getInput ('transcribers')
        })

        transcriberBox.on("input", delay(function () {
          let userText = $(this).val();
          if (userText === "") {
            search()
          }
          else {
          $("#transcriberList").find("option").each(function() {
            if ($(this).val() === userText) {
              search()
            }
          })
        }}, 50))

        radiusSlider.on("change", () => {
          search()
        })

        lemmatizeBox.on("change", () => {
          search()
        })
      })

      // Function to delay keyup and sliderchange event to avoid unnecessary queries for unfinished user input –
      // i. e. if quickly typed "natura", search only for "natura" and not for "n", "na", "nat",...
      function delay (callback, ms) {
        let timer = 0;
        return function() {
          let context = this, args = arguments;
          clearTimeout(timer);
          timer = setTimeout(function () {
            callback.apply(context, args);
          }, ms || 0);
        };
      }

      // Function to get list of indexed values, i. e. titles or transcribers, via an API call
      function getInput (category) {

        // Get queried category
        if (category === 'titles') {

          // Make API request
          $.post("{{ url_for('search.titles') }}").done((apiResponse) => {

            // Get titleList selector and clear the list
            let titleList = $("#titleList")
            titleList.empty()

            // Catch errors
            if (apiResponse.status !== 'OK') {
              console.log(`Error in query for titles!`)
              if (apiResponse.errorData !== undefined) {
                console.log(apiResponse.errorData)
              }
              errorMessage
                .html('Error while getting doc list, please report to technical administrators.')
                .removeClass('text-error')
              return
            }
            console.log(apiResponse)

            // Get titles from apiResponse
            let titles = apiResponse[category]

            // Fill datatable with title names
            titles.forEach(function (item) {titleList.append(`<option>${item}</option>`)})

          })
        }
        else if (category === 'transcribers') {

          // Do exactly the same as before, but with transcribers instead of titles - by time this could be merged into one general function
          $.post("{{ url_for('search.transcribers') }}").done((apiResponse) => {

            let transList = $("#transcriberList")
            transList.empty()

            if (apiResponse.status !== 'OK') {
              console.log(`Error in query for transcribers!`)
              if (apiResponse.errorData !== undefined) {
                console.log(apiResponse.errorData)
              }
              errorMessage
                .html('Error while getting transcribers list, please report to technical administrators.')
                .removeClass('text-error')
              return
            }
            console.log(apiResponse)

            let transcribers = apiResponse[category]

            transcribers.forEach(function (item) {transList.append(`<option>${item}</option>`)})

          })
        }
      }

      // Function to start search process via API call
      function search () {

        // Get selectors for user input and get input
        let keywordBox = $("#keywordBox")
        let transcriptBox = $("#transcriptBox")
        let transcriberBox = $("#transcriberBox")
        let radiusSlider = $("#radiusSlider")
        let lemmatizeBox = $("#lemmatize")
        let spinner = $("#spinner")

        let searchText = keywordBox.val()
        let title = transcriptBox.val();
        let transcriber = transcriberBox.val();
        let radius = radiusSlider.val()
        let lemmatize = lemmatizeBox.prop('checked')

        // Signal search process
        spinner.html(`<div class="spinner-border" role="status"></div>`)

        // Send all user input to ApiSearch (via routing in index.php) and print returned matches
        $.post("{{ url_for('search.keyword') }}", { searchText: searchText, radius: radius, title: title, transcriber: transcriber, lemmatize: lemmatize })
          .done((apiResponse) => {

            // Catch errors
            if (apiResponse.status !== 'OK') {
              console.log(`Error in query`)
              if (apiResponse.errorData !== undefined) {
                console.log(apiResponse.errorData)
              }
              errorMessage
                .html('Error while searching, please report to technical administrators.')
                .removeClass('text-error')
              return
            }

            console.log(apiResponse)

            // Call displayResults-function
            spinner.empty()
            displayResults(apiResponse)

      }).fail((status) => {
        console.log(status)
        spinner.empty()
          errorMessage
          .html('Search is currently not available. Please try again later.')
          .removeClass('text-error')
      })
      }

      // Function to collect and display the search results in readable form
      function displayResults (results) {

        // Get selectors for displaying results
        let errorMessage = $("#error_message")
        let numMatchesTable = $("#numMatchesTable")
        let resultsTableB = $("#resultsTable tbody")
        let resultsTableH = $("#resultsTable thead")


        // Clean tables and divs
        numMatchesTable.empty()
        resultsTableH.empty()
        resultsTableB.empty()
        errorMessage.empty()


        // Get instance of ApmUrlGenerator for creating links to matching docs
        let urlGenerator = new ApmUrlGenerator('{{baseurl}}')

        // Get column data of search result
        let data = results['data']

        // Count matches
        let numMatchedColumns = data.length
        let numMatchedPassages = results['numMatchedPassages']
        let numMatchedDocs = getNumMatchedDocs(data, numMatchedColumns)

        // If there are no matches, display this to the user and empty the table
        if (numMatchedColumns === 0) {
          resultsTableB.empty()
          numMatchesTable
            .html(`<tr><td>Matched Documents: &nbsp</td><td>0</td><tr><td>Matched Passages:</td><td>0</td>`)
            .addClass('text-warning')
        }

        // If there is exactly one matched column, display it with exact information
        else if (numMatchedColumns === 1 && numMatchedPassages === 1) {

          // Display number of matches
          numMatchesTable
            .html(`<tr><td>Matched Documents: &nbsp</td><td>${numMatchedDocs}</td><tr><td>Matched Passages:</td><td>${numMatchedPassages}</td>`)
            .removeClass('text-warning')

          // Make table head
          resultsTableH.empty()
          resultsTableH.append(`<tr><th>Title</th><th>Matched Passage</th><th>Page</th><th>Column</th><th>Transcriber</th><th>Link</th></tr>`)

          // Collect relevant data from API response
          let title = data[0]['title']
          let page = data[0]['page']
          let column = data[0]['column']
          let transcriber = data[0]['transcriber']
          let keywordPosInContext = data[0]['keywordPosInContext']
          let keywordsInContext = data[0]['keywordsInContext']
          let keywords = data[0]['keywords_unlemmatized']
          let searchStrings = data[0]['keywords']


          let docID = data[0]['docID']

          // Get link for matched column
          let url = urlGenerator.sitePageView(docID, page, column)
          let link = getLink(url)

          // Convert the keywords in their context into a single string and highlight the keywords
          let keywordsInContextString = ""

          for (let j = 0; j < keywordsInContext.length; j++) {
            keywordsInContextString = makeKeywordBold(keywordsInContext[j], keywordPosInContext[j], keywords[j], searchStrings, keywords)
            keywordsInContextString = removeBlanksAroundPunctuation(keywordsInContextString)

            // Fill table with results
            resultsTableB.empty()
            resultsTableB.append(
              `<tr><td>${title}</td><td>${keywordsInContextString}</td><td>${page}</td><td>${column}</td><td>${transcriber}</td><td>${link}</td></tr>`)
          }
        }

        // If there is more than one matched column, display them all with exact information
        else {

          // Display number of matches
          numMatchesTable
            .html(`<tr><td>Matched Documents: &nbsp</td><td>${numMatchedDocs}</td><tr><td>Matched Passages:</td><td>${numMatchedPassages}</td>`)
            .removeClass('text-warning')

          // Make table head
          resultsTableH.empty()
          resultsTableH.append(`<tr><th>Title</th><th>Matched Passage</th><th>Page</th><th>Column</th><th>Transcriber</th><th>Link</th></tr>`)
          resultsTableB.empty()

          // Make variable for storing title of preceeding column in the dataset to display only ONE title,
          // if there are plenty matched columns of the same document
          let precTitle = " "

          // Write all matches into the results table
          for (let i = 0; i < numMatchedColumns; i++) {

            // Collect relevant Data from API response
            let title = data[i]['title']
            let page = data[i]['page']
            let column = data[i]['column']
            let transcriber = data[i]['transcriber']
            let keywords = data[i]['keywords_unlemmatized']
            let keywordPosInContext = data[i]['keywordPosInContext']
            let keywordsInContext = data[i]['keywordsInContext']
            let docID = data[i]['docID']
            let searchStrings = data[i]['keywords']


            // Get link for matched column
            let url = urlGenerator.sitePageView(docID, page, column)
            let link = getLink(url)

            // Convert all occurrences of the keyword in their contexts into a single string and highlight the keywords
            let keywordsInContextString = ""

            for (let j = 0; j < keywordsInContext.length; j++) {

              keywordsInContextString = makeKeywordBold(keywordsInContext[j], keywordPosInContext[j], keywords[j], searchStrings, keywords)
              keywordsInContextString = removeBlanksAroundPunctuation(keywordsInContextString)

              // Fill table with results
              if (title === precTitle) {
                resultsTableB.append(
                  `<tr><td></td><td>${keywordsInContextString}</td><td>${page}</td><td>${column}</td><td>${transcriber}</td><td>${link}</td></tr>`)
              }
              else {
                resultsTableB.append(
                  `<tr><td>${title}</td><td>${keywordsInContextString}</td><td>${page}</td><td>${column}</td><td>${transcriber}</td><td>${link}</td></tr>`)
                precTitle = title
              }
            }
          }
        }
      }

      // Function to add a link to a string in html
      function getLink (url) {
        return `<a class="fas fa-external-link-alt" target="_blank" href=${url} </a>`;
        // return `${string} &nbsp &nbsp &nbsp <a class="fas fa-external-link-alt" target="_blank" href=${url} </a>`;
      }

      // Function to calculate total number of matched documents
      function getNumMatchedDocs (data, numColumns) {

        let numDocs = 0
        let prevTitle = ""

        for (i=0; i<numColumns; i++) {
          let title = data[i]['title']
          if (title !== prevTitle) {
            numDocs = numDocs + 1
          }
          prevTitle = title
        }
        return numDocs
      }

      // Function to highlight the searched keyword in its context
      function makeKeywordBold (keywordInContext, keywordPos, keyword, searchStrings, keywords) {

        // Variable holding text with highlighted keyword in it and variable holding the capitalized keyword in it (used above)
        let textWithBoldKeyword = ""

        // Get capitalized keyword and length of keyword for correct boldening in the next steps
        let keywordCap = keyword.replace(/^\w/, (c) => c.toUpperCase())

        // Iterate over all words
        for (i=0; i<keywordInContext.length; i++) {

          // Get current word of keywordInContext-array
          let token = keywordInContext[i]

          // If current index of array is not identical to position of keyword, append word at index to textWithBoldKeyword
          if (token !== keyword && token !== keywordCap) {
            textWithBoldKeyword = textWithBoldKeyword + token + " "
          }

          // If index is identical to position of keyword, append the boldened word to textWithBoldKeyword
          // Therefore, it needs some checks, since we want to bolden only the searched term and not necessarily whole words or
          // even additional words – rarely, but sometimes there can be two words together at the same index in the keywordInContext-array

          else {
            // If matched word is identical to searched keyword, append it to textWithBoldKeyword in bold letters
            //if (token === keyword || token === keywordCap) {
              textWithBoldKeyword = textWithBoldKeyword + token.bold() + " "
           //

            // If matched word is not identical to searched keyword, it needs more checks
            /*else {
              // Get the position of the searched keyword (capitalized and uncapitalized) in the matched word
              // One of these variables will have the value -1, which means the searched keyword is not in the matched word
              let keywordIndex = token.indexOf(keyword)
              let keywordCapIndex = token.indexOf(keywordCap)

              // Variables for the partitions of the matched word
              let matchedPart = ""
              let unmatchedPartPre = ""
              let unmatchedPartPost = ""

              // If the uncapitalized keyword is in the matched word, partition the word to be able to bolden only the part matching the keyword
              if (keywordIndex !== -1) {
                  matchedPart = token.substring(keywordIndex, keywordIndex + keywordLen)
                  unmatchedPartPre =  token.substring(0, keywordIndex)
                  unmatchedPartPost = token.substring(keywordIndex + keywordLen)
              }

              // Same procedure as above, but with the capitalized keyword
              else {
                  matchedPart = token.substring(keywordCapIndex, keywordCapIndex + keywordLen)
                  unmatchedPartPre =  token.substring(0, keywordCapIndex)
                  unmatchedPartPost = token.substring(keywordCapIndex + keywordLen)
              }

              // Append the three substrings to textWithBoldKeyword – bolden the matchedPart
              textWithBoldKeyword = textWithBoldKeyword + " " + unmatchedPartPre + matchedPart.bold() + unmatchedPartPost + " "
            }*/
          }
        }

        // Bolden other keywords, if there is more than one in the original search
        for (i=1; i<keywords.length; i++) {

          let prevIndex = 0

            // Get keyword itself, length and position of keyword in the text with the boldened first keyword
            let keyword = keywords[i] // DAS FUNKTIONIERT SO NICHT MEHR, DA ICH DER FUNKTION NUR EIN UNLEMMATIZED_KEYWORD ÜBERGEBE
            let keywordLen = keyword.length
            let keywordPos = textWithBoldKeyword.indexOf(keyword, prevIndex)

            // If the actual keyword in lower-case is not in the text, get the upper-case keyword and its position
            if (keywordPos === -1) {
              keyword = keyword.replace(/^\w/, (c) => c.toUpperCase())
              keywordPos = textWithBoldKeyword.indexOf(keyword)
            }

            // Get preceeding and succeeding characters of the actual keyword from textWithBoldKeyword
            let precWords = textWithBoldKeyword.slice(0, keywordPos)
            let succWords = textWithBoldKeyword.slice(keywordPos + keywordLen)

            // Concatenate precWords, the boldened keyword and the succWords
            textWithBoldKeyword = precWords + keyword.bold() + succWords
        }

        return textWithBoldKeyword
      }

      function removeBlanksAroundPunctuation (text) {
        text = text.replaceAll(" .", ".")
        text = text.replaceAll(" ,", ",")
        text = text.replaceAll("[ ", "[")
        text = text.replaceAll(" ]", "]")

        return text
      }

    </script>
{%  endblock %}

{% block content %}
    <h1> Search </h1>
<table class="dataTable" id="searchTable">
    <tr><td><b>Keywords</b></td><td><b>Transcript</b></td><td><b>Transcriber</b></td><td><b>Radius</b></td><td align="center"><b>Lemmatization</b></td></tr>

    <tr>
        <td>
            <div id="search_form">
            <label for="keywordBox"></label>
            <input type="text" id="keywordBox" placeholder="">
            </div>
        </td>
        <td>
            <div id="doc_form">
                <label for="transcriptBox"></label>
                <input list="titleList" id="transcriptBox" placeholder="">
                <datalist id="titleList">
                </datalist>
            </div>
        </td>
        <td>
            <div id="transcriber_form">
                <label for="transcriberBox"></label>
                <input list="transcriberList" id="transcriberBox" placeholder="">
                <datalist id="transcriberList">
                </datalist>
            </div>
        </td>
        <td>
            <form>
                <label for="radiusSlider"></label>
                <input type="range" id="radiusSlider" name="radiusSlider" min="3" max="40" value="6">
            </form>
        </td>
      <td align="center">
        <div>
          <input type="checkbox" id="lemmatize" name="lemmatize">
        </div>
      </td>
    </tr>
</table>

  <div id="spinner" class="text-muted" style="margin: 20px; text-align: center;">
    <br><br><br>
  </div>

    <br>
    <div id="error_message"></div>

    <br>
    <table class="doctable" id="numMatchesTable">
    </table>
    <br>

    <br>
    <table class="doctable dataTable no-footer" id="resultsTable">
        <thead></thead>
        <tbody></tbody>
    </table>

    <p></p>

{% endblock %}



