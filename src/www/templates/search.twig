{% extends "base.twig" %}

{% block title %}Search{% endblock %}

{% block extraCSS%}
<style>
    div#search_form {
        margin-bottom: 1rem;
        margin-top: 2rem;
    }

    div#search_results {
        margin-bottom: 2rem;
        margin-left: 2rem;
    }
</style>
{% endblock%}

{% block finalBodyJS %}
    <script>
      $(() => {

        // Get selectors of the searchBox and the searchResults container
        let searchBox = $("#searchBox")
        let docList = $("#docList")
        let contextSlider = $("#contextSlider")

        // Key-Up functions for search box, docList and contextSlider - all call the displayResults-function
        searchBox.on("keyup", () => {
          displayResults(searchBox, contextSlider, docList)
        })

        docList.on("click", () => {
          displayResults(searchBox, contextSlider, docList)
        })

        contextSlider.on("click", () => {
          displayResults(searchBox, contextSlider, docList)
        })
      })

      // Function to collect and display the search results in readable form
      function displayResults (searchBox, contextSlider, docList) {

        // Get selector for output-Div
        let searchResultsDiv = $("#search_results")

        // Get all user input
        let searchText = searchBox.val()
        let sliderVal = contextSlider.val()
        let docName = docList.val();

        // Start search only if keyword has at least two characters
        if (searchText.length > 1) {

          // Send all user input to ApiSearch (via routing in index.php) and print returned matches
          $.post("{{ url_for('search.keyword') }}", { searchText: searchText, sliderVal: sliderVal, docName: docName })
            .done((apiResponse) => {
              console.log(apiResponse)

              // Count matches
              let numMatches = apiResponse['matches'].length

              // If there are no matches, display this to the user
              if (numMatches === 0) {
                searchResultsDiv
                  .html(`'Nothing found for ${apiResponse['searchString']}'<br/> Server time: ${apiResponse['serverTime']}`)
                  .addClass('text-warning')
              }

              // If there is exactly one matched column, display it with exact information
              else if (numMatches === 1) {

                // Collect relevant data from API response
                let title = apiResponse['matches'][0]['title']
                let page = apiResponse['matches'][0]['page']
                let column = apiResponse['matches'][0]['column']
                let transcriber = apiResponse['matches'][0]['transcriber']
                let keywordPosInContext = apiResponse['matches'][0]['keywordPosInContext']
                let keywordsInContext = apiResponse['matches'][0]['keywordsInContext']
                let keywordFreq = apiResponse['matches'][0]['keywordFreq']
                let keyword = apiResponse['searchString']
                let time = apiResponse['serverTime']

                // Convert the keywords in their context into a single string and highlight the keywords
                let keywordsInContextString = ""

                for (let j = 0; j < keywordFreq; j++) {
                  keywordsInContextString = keywordsInContextString + makeKeywordBold(keyword, keywordsInContext[j], keywordPosInContext[j]) + "<br/>"
                }

                // Results as a single string
                let results = (
                    keywordFreq + ' occurence(s) in ' +
                    'column ' + column + ", on " +
                    'page ' + page + ", of " +
                    title + ", " +
                    'transcribed by ' + transcriber + '<br/>').italics() +
                  keywordsInContextString

                // Display results
                searchResultsDiv
                  .html(`<b>${numMatches} column found, which contains the keyword '${keyword}':</b> <br/><br/> ${results} <br/><br/>  (${time})`)
                  .removeClass('text-warning')
              }

              // If there is more than one matched column, display them all with exact information
              else {

                let results = ''
                let keyword = apiResponse['searchString']
                let time = apiResponse['serverTime']

                // Write all matches into a string
                for (let i = 0; i < numMatches; i++) {

                  // Collect relevant Data from API response
                  let title = apiResponse['matches'][i]['title']
                  let page = apiResponse['matches'][i]['page']
                  let column = apiResponse['matches'][i]['column']
                  let transcriber = apiResponse['matches'][i]['transcriber']
                  let keywordPosInContext = apiResponse['matches'][i]['keywordPosInContext']
                  let keywordsInContext = apiResponse['matches'][i]['keywordsInContext']
                  let keywordFreq = apiResponse['matches'][i]['keywordFreq']

                  // Convert all occurrences of the keyword in their contexts into a single string and highlight the keywords
                  let keywordsInContextString = ""

                  for (let j = 0; j < keywordFreq; j++) {
                    keywordsInContextString = keywordsInContextString + makeKeywordBold(keyword, keywordsInContext[j], keywordPosInContext[j]) + "<br/>"
                  }

                  // Results as a single string
                  results = results + '<br/>' +
                    (
                      keywordFreq + ' occurence(s) in ' +
                      'column ' + column + ", on " +
                      'page ' + page + ", of " +
                      title + ", " +
                      'transcribed by ' + transcriber + '<br/>').italics() +
                    keywordsInContextString + '<br/>'
                }

                // Display results
                searchResultsDiv
                  .html(`<b>${numMatches} columns found, which contain the keyword '${keyword}':</b><br/> ${results} <br/><br/> (${time})`)
                  .removeClass('text-warning')
              }
              // If something went wrong, i. e. the OpenSearch server is down, display an error message
            }).fail((status) => {
            console.log(status)
            searchResultsDiv
              .html('Search is currently not available. Please try again later.')
              .removeClass('text-error')

          })
        }
      }

      // Function to highlight the searched keyword in its context
      function makeKeywordBold (keyword, keywordInContext, keywordPos) {

        // Convert text to a list of words
        let words = keywordInContext.trim().split(" ")

        // Variable holding text with highlighted keyword in it and variable holding the capitalized keyword in it (used above)
        let highlightedText = ""
        let keywordUC = keyword.replace(/^\w/, (c) => c.toUpperCase())

        // Iterate over all words
        for (i=0; i<words.length; i++) {

          // If index is not identical to position of keyword, append word at index to highlightedText
          if (i !== keywordPos) {
            highlightedText = highlightedText + words[i] + " "
          }

          // If index is identical to position of keyword and the word in deed includes the keyword, append the boldened word to highlightedText
          else if (words[i].includes(keyword) || words[i].includes(keywordUC)) {
              highlightedText = highlightedText + words[i].bold() + " "
            }

          // If index is identical to position of keyword but the word in deed does not include the keyword,
          // check if the prior word is the actual keyword and if so, append the boldened word to highlightedText
          // (Thr following procedure is necessary, because there can occur differences between the ordering of the words list
          // in this function and the words list of ApiSearch) MAYBE I ADD THE WORDS LIST TO THE API RESPONSE!?
          else if (i !== 0 && (words[i-1].includes(keyword) || words[i-1].includes(keywordUC))) {
              highlightedText = highlightedText.slice(0, -1)
              highlightedText = removeLastWord(highlightedText)
              highlightedText = highlightedText + " " + words[i-1].bold() + " " + words[i] + " "
            }

            // If index is identical to position of keyword but the word in deed does not include the keyword and
            // the prior word is not the actual keyword either, check if the following word is the actual keyword, and if so,
            // append the boldened word to highlightedText
          else if (words[i+1].includes(keyword) || words[i+1].includes(keywordUC)) {
            highlightedText = highlightedText + words[i] + " " + words[i+1].bold() + " "
            i++
          }
          }

        return highlightedText
      }

      function removeLastWord(str) {
        const lastIndexOfSpace = str.lastIndexOf(' ');

        if (lastIndexOfSpace === -1) {
          return str;
        }

        return str.substring(0, lastIndexOfSpace);
      }
    </script>
{%  endblock %}

{% block content %}
    <h1> Search </h1>
    <div id="search_form">
        <label for="searchBox"></label>
        <input type="text" id="searchBox" placeholder="Search..." value="">
    </div>

    <select name="docList" id="docList">

        <option>Search in all documents...</option>
        <option>M-VA-VAT-BAV-Vat.lat.2076</option>
        <option>Bukarest</option>
        <option>Madrid</option>

    </select>
    <p></p>
    <form>
        <label for="contextSlider"></label>
        <input type="range" id="contextSlider" name="contextSlider" min="4" max="40">
    </form>

    <div id="search_results"></div>

{% endblock %}



