{% extends "base.twig" %}

{% block title %}Search{% endblock %}

{% block finalBodyJS %}
    <script>

      // Array to save search results in to have them available for zooming without make a new query
      let data_backup = []

      // Setup event listeners
      $(() => {

        // Get selectors for catching user input
        let keywords_box = $("#keywordBox")
        let doc = $(document)
        let lemmatization_box = $("#lemmatize")
        // let edition_mode = $("#edition_mode")
        // let search_table = $("#searchTable")

        // Get selector for signaling errors to user
        let errorMessageDiv = $("#error_message")

        // Get lists for transcript and transcriber forms
        getListFromOpenSearch ('titles', errorMessageDiv)
        getListFromOpenSearch ('transcribers', errorMessageDiv)

        // Start query when the 'Enter' key is pressed
          doc.on("keyup", function (event) {

            // Get all relevant information for the query
            let user_input = keywords_box.val()
            let num_keywords = user_input.split(" ").length;
            let zoom_slider = $("#zoomSlider")
            let radius = $("#radiusSlider").val()

            // Query only if there is a given user input in the keywords field
            if (event.key === 'Enter' && user_input !== "") {

              // Set minimum of radius slider relative to number of given keywords â€“ otherwise a query for multiple very close keywords could fail
              $("#radiusSlider").prop({'min': num_keywords-1})

              // Set minimum and value of zoom_slider to the values of the radius slider
              zoom_slider.prop("value", radius)

              search()
            }
            else if (event.key === 'Enter' && user_input === "") {
              errorMessageDiv.html(`<br>Please type in a keyword!<br><br>`)
            }
          })

        // Error message if wildcards are combined with lemmatization
        lemmatization_box.on("click",  function (event) {
          let checked = lemmatization_box.prop("checked")
          let user_input = keywords_box.val()
          if (checked && user_input.includes("*")) {
            errorMessageDiv.html(`You cannot use wildcards (*) combined with lemmatization. Maybe it will be possible in the future.`)
          }
        })

        keywords_box.on("keyup",  function (event) {
          let checked = lemmatization_box.prop("checked")
          let user_input = keywords_box.val()
          if (checked && user_input.includes("*")) {
            errorMessageDiv.html(`You cannot use wildcards (*) combined with lemmatization. Maybe it will be possible in the future.`)
          }
        })

        // SCRATCHED CODE FOR QUERYING EDITIONS

        //     edition_mode.on('click', function () {
    //       search_table.empty()
    //       search_table.html(`
    //       <tr><td><b>Keywords</b></td><td class="text-center"><b>Exact Search</b></td><td><b>Text</b></td><td><b>Radius</b></td><td class="text-center"><b>Lemmatization</b></td></tr>
    //
    // <tr>
    //     <td>
    //         <div id="search_form">
    //         <label for="keywordBox"></label>
    //         <input type="text" id="keywordBox" placeholder="">
    //         </div>
    //     </td>
    //     <td>
    //         <div id="doc_form">
    //             <label for="transcriptBox"></label>
    //             <input list="titleList" id="transcriptBox" placeholder="" autocomplete="off">
    //             <datalist id="titleList">
    //             </datalist>
    //         </div>
    //     </td>
    //     <td>
    //         <form>
    //             <label for="radiusSlider"></label>
    //             <input type="range" id="radiusSlider" name="radiusSlider" min="10" max="60" value="18">
    //         </form>
    //     </td>
    //   <td class="text-center">
    //     <div>
    //       <input type="checkbox" id="lemmatize" name="lemmatize">
    //     </div>
    //   </td>
    // </tr>`)
    //     })
      })

      // Function to get list of indexed values, i.e. titles or transcribers, via an API call
      function getListFromOpenSearch(category, errorMessageDiv) {
        let apiUrl = category === 'titles' ? '{{ url_for('search.titles') }}' : '{{ url_for('search.transcribers') }}';
        let listSelector = category === 'titles' ? '#titleList' : '#transcriberList';

        // Make API request
        $.post(apiUrl).done((apiResponse) => {
          // Get list selector and clear the list
          let list = $(listSelector);
          list.empty();

          // Catch errors
          if (apiResponse.status !== 'OK') {
            console.log(`Error in query for ${category}!`);
            if (apiResponse.errorData !== undefined) {
              console.log(apiResponse.errorData);
            }
            errorMessageDiv.html(`Error while getting ${category} list, please report to technical administrators.`)
                    .removeClass('text-error');
            return;
          }

          console.log(apiResponse);

          // Get items from apiResponse
          let items = apiResponse[category];

          // Fill list with item names
          items.forEach((item) => { list.append(`<option>${item}</option>`); });
        });
      }

      // Function to query the OpenSearch index
      function search() {

        // User inputs
        const inputs = {
          searched_phrase: $("#keywordBox").val(),
          title: $("#transcriptBox").val(),
          transcriber: $("#transcriberBox").val(),
          radius: $("#radiusSlider").val(),
          zoom: $("#zoomSlider").val(),
          lemmatize: $("#lemmatize").prop("checked")
        };

        // Selectors
        const spinner = $("#spinner");
        const resultsBody = $("#resultsTable tbody");
        const resultsHead = $("#resultsTable thead");
        const errorMessage = $("#error_message");

        // Clear results table and error message
        resultsBody.empty();
        resultsHead.empty();
        errorMessage.empty();

        // Show spinner
        spinner.html('<div class="spinner-border" role="status"></div>');

        // Make API Call
        $.post("{{ url_for('search.keyword') }}", inputs)
                .done((apiResponse) => {

                  // Catch Error
                  if (apiResponse.status !== 'OK') {
                    console.log(`Error in query`);
                    if (apiResponse.errorData !== undefined) {
                      console.log(apiResponse.errorData);
                    }
                    errorMessage.html('Error while searching, please report to technical administrators.').removeClass('text-error');
                    return;
                  }

                  // Log API response
                  console.log(apiResponse);

                  // Remove spinner
                  spinner.empty();

                  let zoom = new Array(4000).fill(inputs.radius)

                  // Call displayResults-function and save backup of data for zoom handling
                  displayResults(apiResponse.data, apiResponse.lang, apiResponse.num_passages_total, zoom, inputs.radius);
                  data_backup = [apiResponse.data, apiResponse.lang, apiResponse.num_passages_total];
                })
                .fail((status) => {
                  console.log(status);
                  spinner.empty();
                  errorMessage.html('Search is currently not available. Please try again later.').removeClass('text-error');
                });
      }


      // Function to collect and display the search results in a readable form
      function displayResults (data, lang, num_passages, zoom, radius) {

        // Get selectors for displaying results
        let results_body = $("#resultsTable tbody")
        let results_head = $("#resultsTable thead")
        let error_message = $("#error_message")

        // Get instance of ApmUrlGenerator to create links to matched doc pages
        let url_generator = new ApmUrlGenerator('{{baseurl}}')

        // Count matched columns and docs
        let num_columns = data.length
        let num_docs = getNumDocs(data, num_columns)

        // If there are no matches, display this to the user and empty the results table
        if (num_passages === 0) {
          results_head.empty()
          results_body.empty()
          error_message.html(`<br>Nothing found!<br><br>`)
        }

        // If there is exactly one matched passage, display it with exact information
        else if (num_columns === 1 && num_passages === 1) {

          // Make table head
          results_head.empty()
          results_head.append(`<tr><th>Matched Passage (${num_passages})</th><th>Document (${num_docs})</th><th>Foliation</th><th>Transcriber</th><th>Link</th></tr>`)

          // Collect relevant data from API response
          let title = data[0]['title']
          let seq = data[0]['seq']
          let foliation = data[0]['foliation']
          let column = data[0]['column']
          let transcriber = data[0]['transcriber']
          let passages = data[0]['passage_tokenized']
          let tokens_matched = data[0]['tokens_matched']
          let docID = data[0]['docID']
          let transcript_tokenized = data[0]['transcript_tokenized']
          let positions = data[0]['positions']
          
          // Get link for matched page (sequence number)
          let link = getLink(url_generator.sitePageView(docID, seq, column))

          // Slice and highlight passage
          for (let j = 0; j < passages.length; j++) {

            let passage = sliceAndHighlight(transcript_tokenized, tokens_matched, positions[j], radius, zoom[k])


            // Fill table with results - layout depends slightly on the language of the transcripts
            results_body.empty()
            fillResultsTableBody(passage, title, foliation, transcriber, link, lang, zoom)
          }
        }

        // If there is more than one matched passage, display them all with exact information
        else {

          // Make table head
          results_head.empty()
          results_head.append(`<tr><th>Matched Passage (${num_passages})</th><th>Zoom
                                </th><th>Document (${num_docs})</th><th>Foliation</th><th>Transcriber</th><th>Link</th></tr>`)
          results_body.empty()

          // Make variable for storing title of previous column in the dataset to display only the title only once,
          // if there are plenty matched columns/passages in the same work
          let prev_title = ' '
          let k=0

          // Write all matches into the results table
          for (let i = 0; i < num_columns; i++) {

            // Collect relevant Data from API response
            let title = data[i]['title']
            let seq = data[i]['seq']
            let foliation = data[i]['foliation']
            let column = data[i]['column']
            let transcriber = data[i]['transcriber']
            let tokens_matched = data[i]['tokens_matched']
            let passages = data[i]['passage_tokenized']
            let docID = data[i]['docID']
            let transcript_tokenized = data[i]['transcript_tokenized']
            let positions = data[i]['positions']

            // Get link for matched column
            let link = getLink(url_generator.sitePageView(docID, seq, column))

            // Slice and highlight passage
            for (let j = 0; j < passages.length; j++) {
              k=k+1

              let passage = sliceAndHighlight(transcript_tokenized, tokens_matched, positions[j], radius, zoom[k])

              // Fill table with results - layout depends slightly on the language of the transcripts
              fillResultsTableBody(passage, title, foliation, transcriber, link, lang, zoom, prev_title, k)
              prev_title = title
            }
          }
        }
      }

      // Function to add a link to a string in html
      function getLink (url) {
        return `<a class="fas fa-external-link-alt" target="_blank" href=${url} </a>`;
      }

      // Function to calculate total number of matched documents
      function getNumDocs (data, numColumns) {

        let num_docs = 0
        let prev_title = ""

        for (let i=0; i<numColumns; i++) {
          let title = data[i]['title']
          if (title !== prev_title) {
            num_docs = num_docs + 1
          }
          prev_title = title
        }

        return num_docs
      }

      // Function to slice passages out of a transcript depending on zoom value
      // and highlight the searched keywords in the passages depending on radius value
      function sliceAndHighlight (transcript, tokens_matched, position, radius, zoom) {
        
        // SLICE
        let transcript_len = transcript.length
        let passage_start = position-zoom
        let passage_end = parseInt(position)+parseInt(zoom)+1

        if (passage_start < 0) {
          passage_start = 0
        }

        if (passage_end > (transcript_len-1)) {
          passage_end = transcript_len
        }

        let passage = transcript.slice(passage_start, passage_end)

        // HIGHLIGHT
        let passage_highlighted = ""

        // Convert array to string with bold tokens_matched
        for (let i=0; i<passage.length; i++) {
          // Get current word of passage-array
          let token = passage[i]
          // Highlight token, if it is one of the tokens_matched and inside the search radius, not the zoom (!) radius
          if (tokens_matched.indexOf(token) !== -1 && insideRadius(i+passage_start, position, radius)) {
            token = "<mark>" + token + "</mark>"
          }
          // Append token to returned string
          passage_highlighted = passage_highlighted + token + " "
        }

        return removeBlanks(passage_highlighted)
      }

      // Function to check if a matched keyword is inside the search radius
      function insideRadius (index, position, radius) {

        let distance = Math.abs(index-position)

        if (distance>radius) {
            return false
          }
          else {
            return true
          }
      }

      // Function to remove inadequate blanks from passage
      function removeBlanks (text) {
        text = text.replaceAll(" .", ".")
        text = text.replaceAll(" ,", ",")
        text = text.replaceAll(" :", ":")
        text = text.replaceAll("[ ", "[")
        text = text.replaceAll(" ]", "]")

        return text
      }
      
      function fillResultsTableBody(passage, title, foliation, transcriber, link, lang, zoom, prev_title=' ', k) {

        // Get selector
        let results_body = $("#resultsTable tbody")

        // Don't write title into the results table, if it is identical to the title of the previous passage
        if (title === prev_title) {

          if (lang==='la') {
            results_body.append(
                    `<tr><td class="text-justify">${passage}</td><td><label for="zoomSlider${k}"></label><input type="number" id="zoomSlider${k}" name="zoomSlider${k}" min="0" max="80" value=${zoom[k]} </td><td></td><td class="text-center">${foliation}</td><td>${transcriber}</td><td class="text-center">${link}</td></tr>`)
          }
          else if (lang==='he') {
            results_body.append(
                    `<tr><td class="text-justify" class="text-he">${passage}</td><td><label for="zoomSlider${k}"></label><input type="number" id="zoomSlider${k}" name="zoomSlider${k}" min="0" max="80" value=${zoom[k]} </td><td></td><td class="text-center">${foliation}</td><td>${transcriber}</td><td class="text-center">${link}</td></tr>`)
          }
          else if (lang==='ar') {
            results_body.append(
                    `<tr><td class="text-justify" class="text-ar">${passage}</td><td><label for="zoomSlider${k}"></label><input type="number" id="zoomSlider${k}" name="zoomSlider${k}" min="0" max="80" value=${zoom[k]} </td><td></td><td class="text-center">${foliation}</td><td>${transcriber}</td><td class="text-center">${link}</td></tr>`)
          }
        }

      // else if (prev_title === ' ') {
      //   if (lang === 'la') {
      //     results_body.append(
      //             `<tr><td><label for="zoomSlider"></label>
      //     <input type="range" id="zoomSlider" name="radiusSlider" min="0" max="80" value=${zoom}></td><td class="text-justify">${passage}</td><td><label for="zoomSlider"></label><input type="number" id="zoomSlider" name="zoomSlider" min="0" max="80" value=${zoom} </td><td>${title}</td><td class="text-center">${foliation}</td><td>${transcriber}</td><td class="text-center">${link}</td></tr>`)
      //   } else if (lang === 'he') {
      //     results_body.append(
      //             `<tr><td><label for="zoomSlider"></label>
      //     <input type="range" id="zoomSlider" name="radiusSlider" min="0" max="80" value=${zoom}></td><td class="text-justify" class="text-he">${passage}</td><td><label for="zoomSlider"></label><input type="number" id="zoomSlider" name="zoomSlider" min="0" max="80" value=${zoom} </td><td>${title}</td><td class="text-center">${foliation}</td><td>${transcriber}</td><td class="text-center">${link}</td></tr>`)
      //   } else if (lang === 'ar') {
      //     results_body.append(
      //             `<tr><td><label for="zoomSlider"></label>
      //     <input type="range" id="zoomSlider" name="radiusSlider" min="0" max="80" value=${zoom}></td><td class="text-justify" class="text-ar">${passage}</td><td><label for="zoomSlider"></label><input type="number" id="zoomSlider" name="zoomSlider" min="0" max="80" value=${zoom} </td><td>${title}</td><td class="text-center">${foliation}</td><td>${transcriber}</td><td class="text-center">${link}</td></tr>`)
      //   }
      // }

      else {
          if (lang === 'la') {
            results_body.append(
                    `<tr><td class="text-justify">${passage}</td><td><label for="zoomSlider${k}"></label><input type="number" id="zoomSlider${k}" name="zoomSlider${k}" min="0" max="80" value=${zoom[k]} </td><td>${title}</td><td class="text-center">${foliation}</td><td>${transcriber}</td><td class="text-center">${link}</td></tr>`)
          } else if (lang === 'he') {
            results_body.append(
                    `<tr><td class="text-justify" class="text-he">${passage}</td><td><label for="zoomSlider${k}"></label><input type="number" id="zoomSlider${k}" name="zoomSlider${k}" min="0" max="80" value=${zoom[k]} </td><td>${title}</td><td class="text-center">${foliation}</td><td>${transcriber}</td><td class="text-center">${link}</td></tr>`)
          } else if (lang === 'ar') {
            results_body.append(
                    `<tr><td class="text-justify" class="text-ar">${passage}</td><td><label for="zoomSlider${k}"></label><input type="number" id="zoomSlider${k}" name="zoomSlider${k}" min="0" max="80" value=${zoom[k]} </td><td>${title}</td><td class="text-center">${foliation}</td><td>${transcriber}</td><td class="text-center">${link}</td></tr>`)
          }
        }

        // Zoom events
        for (i=1; i<(k+1); i++) {
          let name = "#zoomSlider" + i
          $(name).on("change", function (event) {
            let zoom_slider = $(name)
            let radius_slider = $("#radiusSlider")
            let index = name.length-1
            zoom[name[index]] = zoom_slider.val()
            let radius = radius_slider.val()
            displayResults(data_backup[0], data_backup[1], data_backup[2], zoom, radius)
          })
      }

        return true
      }

    </script>

{%  endblock %}

{% block content %}
    <h1> Search </h1>
  <p>
    Type in a keyword and press 'Enter' to search.
{#  <div>#}
{#  <b>Edition Mode</b>#}
{#    <input type="checkbox" id="edition_mode" name="edition_mode">#}
{#  </div>#}
  </p>

  <table class="docTable dataTable" id="searchTable">
    <tr><th>Keywords</th><th>Transcript</th><th>Transcriber</th><th>Radius</th><th class="text-center">Lemmatization</th></tr>
    <tr>
        <td>
            <div id="search_form">
            <label for="keywordBox"></label>
            <input type="text" id="keywordBox" placeholder="">
            </div>
        </td>
        <td>
          <div id="doc_form">
            <label for="transcriptBox"></label>
            <input list="titleList" id="transcriptBox" placeholder="" autocomplete="off">
            <datalist id="titleList">
            </datalist>
          </div>
        </td>
        <td>
          <div id="transcriber_form">
            <label for="transcriberBox"></label>
            <input list="transcriberList" id="transcriberBox" placeholder="" autocomplete="off">
            <datalist id="transcriberList">
            </datalist>
          </div>
        </td>
      <td>
        <form>
          <label for="radiusSlider"></label>
          <input type="number" id="radiusSlider" name="radiusSlider" min="0" max="80" value="30">
        </form>
      </td>
      <td>
        <div class="text-center">
          <input type="checkbox" label="lemmatize" id="lemmatize" name="lemmatize">
        </div>
      </td>
    </tr>
</table>

  <div id="error_message">
  </div>

  <div id="spinner" class="text-muted" style="margin: 20px; text-align: center;">
  </div>

    <div id="noMatchesDiv">
    </div>

    <table class="doctable dataTable no-footer" id="resultsTable">
        <thead></thead>
        <tbody></tbody>
    </table>

    <p></p>

{% endblock %}



