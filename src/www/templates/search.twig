{% extends "base.twig" %}

{% block title %}Search{% endblock %}

{% block finalBodyJS %}
    <script>

      // Array to save search results in to have them available for zooming without make a new query
      let data_for_zooming = []

      // Setup event listeners
      $(() => {

        // Get selectors for catching user input
        let keywords_box = $("#keywordBox")
        let lemmatization_box = $("#lemmatize")
        // let edition_mode = $("#edition_mode")
        // let search_table = $("#searchTable")

        // Get selector for signaling errors to user
        let errorMessageDiv = $("#error_message")

        // Get lists for transcript and transcriber forms
        getListFromOpenSearch ('titles', errorMessageDiv)
        getListFromOpenSearch ('transcribers', errorMessageDiv)

        // Start query when the search button is pressed
          $("#searchButton").on("click", function () {

            // Get all relevant information for the query
            let user_input = keywords_box.val()

            // Query only if there is a given user input in the keywords field
            if (user_input !== "") {
              search()
            }
            else {
              errorMessageDiv.html(`<br>Please type in a keyword!<br><br>`)
            }
          })

        // Error message if wildcards are combined with lemmatization
        lemmatization_box.on("click",  function (event) {
          let checked = lemmatization_box.prop("checked")
          let user_input = keywords_box.val()
          if (checked && user_input.includes("*")) {
            errorMessageDiv.html(`You cannot use wildcards (*) combined with lemmatization. Maybe it will be possible in the future.`)
          }
        })

        keywords_box.on("keyup",  function (event) {
          let checked = lemmatization_box.prop("checked")
          let user_input = keywords_box.val()
          if (checked && user_input.includes("*")) {
            errorMessageDiv.html(`You cannot use wildcards (*) combined with lemmatization. Maybe it will be possible in the future.`)
          }
        })

        // SCRATCHED CODE FOR QUERYING EDITIONS

        //     edition_mode.on('click', function () {
    //       search_table.empty()
    //       search_table.html(`
    //       <tr><td><b>Keywords</b></td><td class="text-center"><b>Exact Search</b></td><td><b>Text</b></td><td><b>Radius</b></td><td class="text-center"><b>Lemmatization</b></td></tr>
    //
    // <tr>
    //     <td>
    //         <div id="search_form">
    //         <label for="keywordBox"></label>
    //         <input type="text" id="keywordBox" placeholder="">
    //         </div>
    //     </td>
    //     <td>
    //         <div id="doc_form">
    //             <label for="transcriptBox"></label>
    //             <input list="titleList" id="transcriptBox" placeholder="" autocomplete="off">
    //             <datalist id="titleList">
    //             </datalist>
    //         </div>
    //     </td>
    //     <td>
    //         <form>
    //             <label for="radiusSlider"></label>
    //             <input type="range" id="radiusSlider" name="radiusSlider" min="10" max="60" value="18">
    //         </form>
    //     </td>
    //   <td class="text-center">
    //     <div>
    //       <input type="checkbox" id="lemmatize" name="lemmatize">
    //     </div>
    //   </td>
    // </tr>`)
    //     })
      })

      // Function to get list of indexed values, i.e. titles or transcribers, via an API call
      function getListFromOpenSearch(category, errorMessageDiv) {
        let apiUrl = category === 'titles' ? '{{ url_for('search.titles') }}' : '{{ url_for('search.transcribers') }}';
        let listSelector = category === 'titles' ? '#titleList' : '#transcriberList';

        // Make API request
        $.post(apiUrl).done((apiResponse) => {
          // Get list selector and clear the list
          let list = $(listSelector);
          list.empty();

          // Catch errors
          if (apiResponse.status !== 'OK') {
            console.log(`Error in query for ${category}!`);
            if (apiResponse.errorData !== undefined) {
              console.log(apiResponse.errorData);
            }
            errorMessageDiv.html(`Error while getting ${category} list, please report to technical administrators.`)
                    .removeClass('text-error');
            return;
          }

          console.log(apiResponse);

          // Get items from apiResponse
          let items = apiResponse[category];

          // Fill list with item names
          items.forEach((item) => { list.append(`<option>${item}</option>`); });
        });
      }

      // Function to query the OpenSearch index
      function search() {

        // Clear data_for_zooming
        data_for_zooming = []

        // User inputs
        const inputs = {
          searched_phrase: $("#keywordBox").val(),
          title: $("#transcriptBox").val(),
          transcriber: $("#transcriberBox").val(),
          radius: parseInt($("#radiusSlider").val()) + 1,
          zoom: $("#zoomSlider").val(),
          lemmatize: $("#lemmatize").prop("checked")
        };

        // Selectors
        const spinner = $("#spinner");
        const resultsBody = $("#resultsTable tbody");
        const resultsHead = $("#resultsTable thead");
        const errorMessage = $("#error_message");

        // Clear results table and error message
        resultsBody.empty();
        resultsHead.empty();
        errorMessage.empty();

        // Show spinner
        spinner.html('<div class="spinner-border" role="status"></div>');

        // Make API Call
        $.post("{{ url_for('search.keyword') }}", inputs)
                .done((apiResponse) => {

                  // Catch Error
                  if (apiResponse.status !== 'OK') {
                    console.log(`Error in query`);
                    if (apiResponse.errorData !== undefined) {
                      console.log(apiResponse.errorData);
                    }
                    errorMessage.html('Error while searching, please report to technical administrators.').removeClass('text-error');
                    return;
                  }

                  // Log API response
                  console.log(apiResponse);

                  // Remove spinner
                  spinner.empty();

                  let zoom = new Array(apiResponse.num_passages_total+1).fill(inputs.radius)
                  
                  // Call displayResults-function and save backup of data for zoom handling
                  displayResults(apiResponse.data, apiResponse.lang, apiResponse.num_passages_total, zoom, inputs.radius);
                })
                .fail((status) => {
                  console.log(status);
                  spinner.empty();
                  errorMessage.html('Search is currently not available. Please try again later.').removeClass('text-error');
                });
      }


      // Function to collect and display the search results in a readable form
      function displayResults (data, lang, num_passages, zoom, radius) {

        // Get selectors for displaying results
        let results_body = $("#resultsTable tbody")
        let results_head = $("#resultsTable thead")
        let error_message = $("#error_message")

        // Get instance of ApmUrlGenerator to create links to matched doc pages
        let url_generator = new ApmUrlGenerator('{{baseurl}}')

        // Count matched columns and docs
        let num_columns = data.length
        let num_docs = getNumDocs(data, num_columns)

        // If there are no matches, display this to the user and empty the results table
        if (num_passages === 0) {
          results_head.empty()
          results_body.empty()
          error_message.html(`<br>Nothing found!<br><br>`)
        }

        else {

          // Make table head
          results_head.empty()
          results_head.append(`<tr><th>Matched Passage (${num_passages})</th><th><span title="Number of tokens, i. e. words or punctuation marks, to display before and after your first keyword. A value of 0 means that only the tokens matching your first keyword are displayed."><label for="zoomGlobal"></label><input type="number" id="zoomGlobal" name="zoomGlobal" min="0" max="80" value=${zoom[0]}></span>
                                </th><th>Document (${num_docs})</th><th>Foliation</th><th>Transcriber</th><th>Link</th></tr>`)
          results_body.empty()

          // Make variable for storing title of previous column in the dataset to display only the title only once,
          // if there are plenty matched columns/passages in the same work
          let prev_title = ' '
          let k=0

          // Write all matches into the results table
          for (let i = 0; i < num_columns; i++) {

            // Collect relevant Data from API response
            let title = data[i]['title']
            let seq = data[i]['seq']
            let foliation = data[i]['foliation']
            let column = data[i]['column']
            let transcriber = data[i]['transcriber']
            let tokens_matched = data[i]['tokens_matched']
            let passages = data[i]['passage_tokenized']
            let docID = data[i]['docID']
            let transcript_tokenized = data[i]['transcript_tokenized']
            let positions = data[i]['positions']

            // Get link for matched column
            let link = getLink(url_generator.sitePageView(docID, seq, column))

            // Slice and highlight passage
            for (let j = 0; j < passages.length; j++) {
              k=k+1

              data_for_zooming.push({
                'transcript_tokenized': transcript_tokenized,
                'tokens_matched': tokens_matched,
                'position': positions[j]})

              let passage = sliceAndHighlight(transcript_tokenized, tokens_matched, positions[j], radius, zoom[k])

              // Fill table with results - layout depends slightly on the language of the transcripts
              fillResultsTableBody(passage, title, foliation, transcriber, link, lang, zoom, prev_title, k)
              prev_title = title
            }
          }
        }
      }

      // Function to update search results when user is zooming
      function updateResults (data, zoom, radius, index) {

        // Get selector for updating results
        let results_body = document.getElementById("resultsTable")

        // Get the relevant data
        let tokens_matched = data[index-1]['tokens_matched']
        // let passages = data[index-1]['passage_tokenized']
        let transcript_tokenized = data[index-1]['transcript_tokenized']
        let position = data[index-1]['position']

        // Slice and highlight passage
        let passage = sliceAndHighlight(transcript_tokenized, tokens_matched, position, radius, zoom[index])
        results_body.rows[index].cells[0].innerHTML = passage;
      }

      // Function to add a link to a string in html
      function getLink (url) {
        return `<a class="fas fa-external-link-alt" target="_blank" href=${url} </a>`;
      }

      // Function to calculate total number of matched documents
      function getNumDocs (data, numColumns) {

        let num_docs = 0
        let prev_title = ""

        for (let i=0; i<numColumns; i++) {
          let title = data[i]['title']
          if (title !== prev_title) {
            num_docs = num_docs + 1
          }
          prev_title = title
        }

        return num_docs
      }

      // Function to slice passages out of a transcript depending on zoom value
      // and highlight the searched keywords in the passages depending on radius value
      function sliceAndHighlight (transcript, tokens_matched, position, radius, zoom) {
        
        // SLICE
        let transcript_len = transcript.length
        let passage_start = position-zoom
        let passage_end = parseInt(position)+parseInt(zoom)+1

        if (passage_start < 0) {
          passage_start = 0
        }

        if (passage_end > (transcript_len-1)) {
          passage_end = transcript_len
        }

        let passage = transcript.slice(passage_start, passage_end)

        // HIGHLIGHT
        let passage_highlighted = ""

        // Convert array to string with bold tokens_matched
        for (let i=0; i<passage.length; i++) {
          // Get current word of passage-array
          let token = passage[i]
          // Highlight token, if it is one of the tokens_matched and inside the search radius, not the zoom (!) radius
          if (tokens_matched.indexOf(token) !== -1 && insideRadius(i+passage_start, position, radius)) {
            token = "<mark>" + token + "</mark>"
          }
          // Append token to returned string
          passage_highlighted = passage_highlighted + token + " "
        }

        return removeBlanks(passage_highlighted)
      }

      // Function to check if a matched keyword is inside the search radius
      function insideRadius (index, position, radius) {

        let distance = Math.abs(index-position)
        if (distance>radius) {
            return false
          }
          else {
            return true
          }
      }

      // Function to remove inadequate blanks from passage
      function removeBlanks (text) {
        text = text.replaceAll(" .", ".")
        text = text.replaceAll(" ,", ",")
        text = text.replaceAll(" :", ":")
        text = text.replaceAll("[ ", "[")
        text = text.replaceAll(" ]", "]")

        return text
      }
      
      function fillResultsTableBody(passage, title, foliation, transcriber, link, lang, zoom, prev_title=' ', k) {

        // Get selector
        let results_body = $("#resultsTable tbody")

        // Don't write title into the results table, if it is identical to the title of the previous passage
        if (title === prev_title) {

          if (lang==='la') {
            results_body.append(
                    `<tr><td class="text-justify" style="width: 50em">${passage}</td><td style="text-align: right"><label for="zoomSlider${k}"></label><input type="number" id="zoomSlider${k}" name="zoomSlider${k}" min="0" max="80" value=${zoom[k]} </td><td></td><td class="text-center">${foliation}</td><td>${transcriber}</td><td class="text-center">${link}</td></tr>`)
          }
          else if (lang==='he') {
            results_body.append(
                    `<tr><td class="text-justify" class="text-he" style="width: 50em">${passage}</td><td style="text-align: right"><label for="zoomSlider${k}"></label><input type="number" id="zoomSlider${k}" name="zoomSlider${k}" min="0" max="80" value=${zoom[k]} </td><td></td><td class="text-center">${foliation}</td><td>${transcriber}</td><td class="text-center">${link}</td></tr>`)
          }
          else if (lang==='ar') {
            results_body.append(
                    `<tr><td class="text-justify" class="text-ar" style="width: 50em">${passage}</td><td style="text-align: right"><label for="zoomSlider${k}"></label><input type="number" id="zoomSlider${k}" name="zoomSlider${k}" min="0" max="80" value=${zoom[k]} </td><td></td><td class="text-center">${foliation}</td><td>${transcriber}</td><td class="text-center">${link}</td></tr>`)
          }
        }

      else {
          if (lang === 'la') {
            results_body.append(
                    `<tr><td class="text-justify" style="width: 50em">${passage}</td><td style="text-align: right"><label for="zoomSlider${k}"></label><input type="number" id="zoomSlider${k}" name="zoomSlider${k}" min="0" max="80" value=${zoom[k]} </td><td>${title}</td><td class="text-center">${foliation}</td><td>${transcriber}</td><td class="text-center">${link}</td></tr>`)
          } else if (lang === 'he') {
            results_body.append(
                    `<tr><td class="text-justify" class="text-he" style="width: 50em">${passage}</td><td style="text-align: right"><label for="zoomSlider${k}"></label><input type="number" id="zoomSlider${k}" name="zoomSlider${k}" min="0" max="80" value=${zoom[k]} </td><td>${title}</td><td class="text-center">${foliation}</td><td>${transcriber}</td><td class="text-center">${link}</td></tr>`)
          } else if (lang === 'ar') {
            results_body.append(
                    `<tr><td class="text-justify" class="text-ar" style="width: 50em">${passage}</td><td style="text-align: right"><label for="zoomSlider${k}"></label><input type="number" id="zoomSlider${k}" name="zoomSlider${k}" min="0" max="80" value=${zoom[k]} </td><td>${title}</td><td class="text-center">${foliation}</td><td>${transcriber}</td><td class="text-center">${link}</td></tr>`)
          }
        }

        // Zoom events
        let zoom_global = $("#zoomGlobal")
        $(zoom_global).on("change", function (event) {
          for (i=1; i<(k+1); i++) {
            let name = "#zoomSlider" + i
            let value = zoom_global.val()
            $(name).prop("value", value)
            let zoom_slider = $(name)
            let radius_slider = $("#radiusSlider")
            let index = name.match(/\d/g);
            index = index.join("");
            zoom[index] = zoom_slider.val()
            let radius = parseInt(radius_slider.val()) + 1
            updateResults(data_for_zooming, zoom, radius, index)
          }
          })


        for (i=1; i<(k+1); i++) {
          let name = "#zoomSlider" + i
          $(name).on("change", function (event) {
            let zoom_slider = $(name)
            let radius_slider = $("#radiusSlider")
            let index = name.match(/\d/g);
            index = index.join("");
            zoom[index] = zoom_slider.val()
            let radius = parseInt(radius_slider.val()) + 1
            updateResults(data_for_zooming, zoom, radius, index)
          })
      }

        return true
      }

    </script>

{%  endblock %}

{% block content %}
    <h1> Search </h1>

  <br>
  <table class="docTable dataTable" id="searchTable">
    <tr><th><span title="You can use the wildcard '*' to search for words with a specific part, like 'philosoph*', '*losophus' or '*soph*'.">Keywords</span></th><th><span title="Here you can choose a specific transcript to search in.">Transcript</span></th><th><span title="Here you can limit your search to transcripts by a specific transcriber.">Transcriber</span></th><th style="text-align: center"><span title="Here you can specify how many tokens, i. e. words or punctuation marks, are allowed to occur between your first keyword and the following ones. A value of 0 means that only the occurrence of directly consecutive keywords counts as a match.">Keyword Distance</span></th><th class="text-center"><span title="If checked, all conjugated or declined forms of your keywords will count as matches.">Lemmatization</span></th></tr>
    <tr>
        <td>
            <div id="search_form">
            <label for="keywordBox"></label>
            <input type="text" id="keywordBox" placeholder="">
            </div>
        </td>
        <td>
          <div id="doc_form">
            <label for="transcriptBox"></label>
            <input list="titleList" id="transcriptBox" placeholder="" autocomplete="off">
            <datalist id="titleList">
            </datalist>
          </div>
        </td>
        <td>
          <div id="transcriber_form">
            <label for="transcriberBox"></label>
            <input list="transcriberList" id="transcriberBox" placeholder="" autocomplete="off">
            <datalist id="transcriberList">
            </datalist>
          </div>
        </td>
      <td style="text-align: center">
        <form>
          <label for="radiusSlider"></label>
          <input type="number" id="radiusSlider" name="radiusSlider" min="0" max="80" value="10">
        </form>
      </td>
      <td>
        <div class="text-center">
          <input type="checkbox" label="lemmatize" id="lemmatize" name="lemmatize">
        </div>
      </td>
      <td>
        <button type="button" label="Search" id="searchButton" name="Search" style="background-color: white">Search!</button>
      </td>
    </tr>
</table>

  <div id="error_message">
  </div>

  <div id="spinner" class="text-muted" style="margin: 20px; text-align: center;">
  </div>

    <div id="noMatchesDiv">
    </div>

    <table class="doctable dataTable no-footer" id="resultsTable">
        <thead></thead>
        <tbody></tbody>
    </table>

    <p></p>

{% endblock %}



