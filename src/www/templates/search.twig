{% extends "base.twig" %}

{% block title %}Search{% endblock %}

{% block finalBodyJS %}
    <script>
      $(() => {

        // Get selectors of searchBox, docBox and contextSlider
        let searchBox = $("#searchBox")
        let docBox = $("#docBox")
        let transBox = $("#transcriberBox")
        let contextSlider = $("#contextSlider")

        // Key-Up functions for search box, docBox and contextSlider - all call the displayResults-function –
        searchBox.on("keyup", delay(function () {
          displayResults(searchBox, contextSlider, docBox, transBox)
        }, 300))

        docBox.on("click", () => {
          getValues ('docs')
        })

        docBox.on("input", delay(function () {
          let userText = $(this).val();
          $("#docList").find("option").each(function() {
            if ($(this).val() === userText || userText === "") {
              displayResults(searchBox, contextSlider, docBox, transBox)
            }
          })
        }, 50))

        transBox.on("click", () => {
          getValues ('transcribers')
        })

        transBox.on("input", delay(function () {
          let userText = $(this).val();
          $("#transcriberList").find("option").each(function() {
            if ($(this).val() === userText || userText === "") {
              displayResults(searchBox, contextSlider, docBox, transBox)
            }
          })
        }, 50))

        contextSlider.on("change", () => {
          displayResults(searchBox, contextSlider, docBox, transBox)
        })
      })

      // Function to delay keyup and sliderchange event to avoid unnecessary queries for unfinished user input –
      // i. e. if quickly typed "natura", search only for "natura" and not for "n", "na", "nat",...
      function delay(callback, ms) {
        var timer = 0;
        return function() {
          var context = this, args = arguments;
          clearTimeout(timer);
          timer = setTimeout(function () {
            callback.apply(context, args);
          }, ms || 0);
        };
      }

      // Function to get list of docs from ApiSearch
      function getValues (category) {

        if (category === 'docs') {

          $.post("{{ url_for('search.docs') }}").done((apiResponse) => {

            let docList = $("#docList")
            docList.empty()

            if (apiResponse.status !== 'OK') {
              console.log(`Error in query for docs!`)
              if (apiResponse.errorData !== undefined) {
                console.log(apiResponse.errorData)
              }
              errorMessage
                .html('Error while getting doc list, please report to technical administrators.')
                .removeClass('text-error')
              return
            }
            console.log(apiResponse)

            let docs = apiResponse[category]

            docs.forEach(function (item) {docList.append(`<option>${item}</option>`)})

          })
        }
        else if (category === 'transcribers') {

          $.post("{{ url_for('search.transcribers') }}").done((apiResponse) => {

            let transList = $("#transcriberList")
            transList.empty()

            if (apiResponse.status !== 'OK') {
              console.log(`Error in query for transcribers!`)
              if (apiResponse.errorData !== undefined) {
                console.log(apiResponse.errorData)
              }
              errorMessage
                .html('Error while getting transcribers list, please report to technical administrators.')
                .removeClass('text-error')
              return
            }
            console.log(apiResponse)

            let transcribers = apiResponse[category]

            transcribers.forEach(function (item) {transList.append(`<option>${item}</option>`)})

          })
        }
      }

      // Function to collect and display the search results in readable form
      function displayResults (searchBox, contextSlider, docBox, transBox) {

        // Get selectors
        let errorMessage = $("#error_message")
        let numMatchesTable = $("#numMatchesTable")
        let resultsTableB = $("#resultsTable tbody")
        let resultsTableH = $("#resultsTable thead")

        // Make tables and divs clean
        numMatchesTable.empty()
        resultsTableH.empty()
        resultsTableB.empty()
        errorMessage.empty()

        // Get all user input
        let searchText = searchBox.val()
        let sliderVal = contextSlider.val()
        let docName = docBox.val();
        let transcriber = transBox.val();

        // Get instance of ApmUrlGenerator for creating links to matching docs
        let urlGenerator = new ApmUrlGenerator('{{baseurl}}')

          // Send all user input to ApiSearch (via routing in index.php) and print returned matches
          $.post("{{ url_for('search.keyword') }}", { searchText: searchText, sliderVal: sliderVal, docName: docName, transcriber: transcriber })
            .done((apiResponse) => {

              if (apiResponse.status !== 'OK') {
                console.log(`Error in query`)
                if (apiResponse.errorData !== undefined) {
                 console.log(apiResponse.errorData)
                }
                errorMessage
                  .html('Error while searching, please report to technical administrators.')
                  .removeClass('text-error')
                return
              }
              console.log(apiResponse)

              // Count matches
              let numMatchedColumns = apiResponse['data'].length
              let numMatches = apiResponse['numMatches']
              let numMatchedDocs = getNumMatchedDocs(apiResponse['data'], numMatchedColumns)

              // If there are no matches, display this to the user and empty the table
              if (numMatchedColumns === 0) {
                resultsTableB.empty()
                numMatchesTable
                  .html(`<tr><td>Matched Documents: &nbsp</td><td>0</td><tr><td>Matched Passages:</td><td>0</td>`)
                  .addClass('text-warning')
              }

              // If there is exactly one matched column, display it with exact information
              else if (numMatchedColumns === 1 && numMatches === 1) {

                // Display number of matches
                numMatchesTable
                  .html(`<tr><td>Matched Documents: &nbsp</td><td>${numMatchedDocs}</td><tr><td>Matched Passages:</td><td>${numMatches}</td>`)
                  .removeClass('text-warning')

                // Make table head
                resultsTableH.empty()
                resultsTableH.append(`<tr><th>Title</th><th>Matched Passage</th><th>Page</th><th>Column</th><th>Transcriber</th><th>Link</th></tr>`)

                // Collect relevant data from API response
                let title = apiResponse['data'][0]['title']
                let page = apiResponse['data'][0]['page']
                let column = apiResponse['data'][0]['column']
                let transcriber = apiResponse['data'][0]['transcriber']
                let keywordPosInContext = apiResponse['data'][0]['keywordPosInContext']
                let keywordsInContext = apiResponse['data'][0]['keywordsInContext']
                let keywordFreq = apiResponse['data'][0]['keywordFreq']
                let keywords = apiResponse['data'][0]['keywords']
                let docID = apiResponse['data'][0]['docID']

                // Add link to matched column
                let url = urlGenerator.sitePageView(docID, page, column)
                let link = getLink(url)

                // Convert the keywords in their context into a single string and highlight the keywords
                let keywordsInContextString = ""

                for (let j = 0; j < keywordFreq; j++) {
                  keywordsInContextString = makeKeywordBold(keywordsInContext[j], keywordPosInContext[j], keywords)

                  // Fill table with results
                  resultsTableB.empty()
                  resultsTableB.append(
                    `<tr><td>${title}</td><td>${keywordsInContextString}</td><td>${page}</td><td>${column}</td><td>${transcriber}</td><td>${link}</td></tr>`)
                }
              }

              // If there is more than one matched column, display them all with exact information
              else {

                var precTitle = " "

                // Display number of matches
                numMatchesTable
                  .html(`<tr><td>Matched Documents: &nbsp</td><td>${numMatchedDocs}</td><tr><td>Matched Passages:</td><td>${numMatches}</td>`)
                  .removeClass('text-warning')

                // Make table head
                resultsTableH.empty()
                resultsTableH.append(`<tr><th>Title</th><th>Matched Passage</th><th>Page</th><th>Column</th><th>Transcriber</th><th>Link</th></tr>`)
                resultsTableB.empty()

                // Write all matches into the results table
                for (let i = 0; i < numMatchedColumns; i++) {

                  // Collect relevant Data from API response
                  let title = apiResponse['data'][i]['title']
                  let page = apiResponse['data'][i]['page']
                  let column = apiResponse['data'][i]['column']
                  let transcriber = apiResponse['data'][i]['transcriber']
                  let keywords = apiResponse['data'][i]['keywords']
                  let keywordPosInContext = apiResponse['data'][i]['keywordPosInContext']
                  let keywordsInContext = apiResponse['data'][i]['keywordsInContext']
                  let keywordFreq = apiResponse['data'][i]['keywordFreq']
                  let docID = apiResponse['data'][i]['docID']

                  // Add link to matched column
                  let url = urlGenerator.sitePageView(docID, page, column)
                  let link = getLink(url)

                  // Convert all occurrences of the keyword in their contexts into a single string and highlight the keywords
                  let keywordsInContextString = ""

                  for (let j = 0; j < keywordFreq; j++) {

                    keywordsInContextString = makeKeywordBold(keywordsInContext[j], keywordPosInContext[j], keywords)

                    // Fill table with results
                    if (title === precTitle) {
                    resultsTableB.append(
                      `<tr><td></td><td>${keywordsInContextString}</td><td>${page}</td><td>${column}</td><td>${transcriber}</td><td>${link}</td></tr>`)
                      }
                      else {
                      resultsTableB.append(
                        `<tr><td>${title}</td><td>${keywordsInContextString}</td><td>${page}</td><td>${column}</td><td>${transcriber}</td><td>${link}</td></tr>`)
                      precTitle = title
                      }
                    }
                  }
              }
              // If something went wrong, display an error message
            }).fail((status) => {
            console.log(status)
            errorMessage
              .html('Search is currently not available. Please try again later.')
              .removeClass('text-error')

          })
      }

      // Function to add a link to a string in html
      function getLink (url) {
        return `<a class="fas fa-external-link-alt" target="_blank" href=${url} </a>`;
        // return `${string} &nbsp &nbsp &nbsp <a class="fas fa-external-link-alt" target="_blank" href=${url} </a>`;
      }

      // Function to calculate total number of matched documents
      function getNumMatchedDocs (data, numColumns) {

        let numDocs = 0
        let prevTitle = ""

        for (i=0; i<numColumns; i++) {
          let title = data[i]['title']
          if (title !== prevTitle) {
            numDocs = numDocs + 1
          }
          prevTitle = title
        }
        return numDocs
      }

      // Function to highlight the searched keyword in its context
      function makeKeywordBold (keywordInContext, keywordPos, keywords) {

        // Variable holding text with highlighted keyword in it and variable holding the capitalized keyword in it (used above)
        let textWithBoldKeyword = ""
        let keyword = keywords[0]

        // Get capitalized keyword and length of keyword for correct boldening in the next steps
        let keywordCap = keyword.replace(/^\w/, (c) => c.toUpperCase())
        let keywordLen = keyword.length

        // Iterate over all words
        for (i=0; i<keywordInContext.length; i++) {

          // Get current word of keywordInContext-array
          let stringContainingKeyword = keywordInContext[i]

          // If current index of array is not identical to position of keyword, append word at index to textWithBoldKeyword
          if (i !== keywordPos) {
            textWithBoldKeyword = textWithBoldKeyword + stringContainingKeyword + " "
          }

          // If index is identical to position of keyword, append the boldened word to textWithBoldKeyword
          // Therefore, it needs some checks, since we want to bolden only the searched term and not necessarily whole words or
          // even additional words – rarely, but sometimes there can be two words together at the same index in the keywordInContext-array

          else {
            // If matched word is identical to searched keyword, append it to textWithBoldKeyword in bold letters
            if (stringContainingKeyword === keyword || stringContainingKeyword === keywordCap) {
              textWithBoldKeyword = textWithBoldKeyword + stringContainingKeyword.bold() + " "
            }

            // If matched word is not identical to searched keyword, it needs more checks
            else {
              // Get the position of the searched keyword (capitalized and uncapitalized) in the matched word
              // One of these variables will have the value -1, which means the searched keyword is not in the matched word
              let keywordIndex = stringContainingKeyword.indexOf(keyword)
              let keywordCapIndex = stringContainingKeyword.indexOf(keywordCap)

              // Variables for the partitions of the matched word
              let matchedPart = ""
              let unmatchedPartPre = ""
              let unmatchedPartPost = ""

              // If the unapitalized keyword is in the matched word, partition the word to be able to bolden only the part matching the keyword
              if (keywordIndex !== -1) {
                  matchedPart = stringContainingKeyword.substring(keywordIndex, keywordIndex + keywordLen)
                  unmatchedPartPre =  stringContainingKeyword.substring(0, keywordIndex)
                  unmatchedPartPost = stringContainingKeyword.substring(keywordIndex + keywordLen)
              }

              // Same procedure as above, but with the capitalized keyword
              else {
                  matchedPart = stringContainingKeyword.substring(keywordCapIndex, keywordCapIndex + keywordLen)
                  unmatchedPartPre =  stringContainingKeyword.substring(0, keywordCapIndex)
                  unmatchedPartPost = stringContainingKeyword.substring(keywordCapIndex + keywordLen)
              }

              // Append the three substrings to textWithBoldKeyword – bolden the matchedPart
              textWithBoldKeyword = textWithBoldKeyword + " " + unmatchedPartPre + matchedPart.bold() + unmatchedPartPost + " "
            }
          }
        }

        // Bolden other keywords, if there is more than one in the original search
        for (i=1; i<keywords.length; i++) {

          // Get keyword itself, length and position of keyword in the text with the boldened first keyword
          let keyword = keywords[i]
          let keywordLen = keyword.length
          let keywordPos = textWithBoldKeyword.indexOf (keyword)

          // If the actual keyword in lower-case is not in the text, get the upper-case keyword and its position
          if (keywordPos === -1) {
            keyword = keyword.replace(/^\w/, (c) => c.toUpperCase())
            keywordPos = textWithBoldKeyword.indexOf (keyword)
          }

          // Get preceeding and succeeding characters of the actual keyword from textWithBoldKeyword
          let precWords = textWithBoldKeyword.slice(0, keywordPos)
          let succWords = textWithBoldKeyword.slice(keywordPos+keywordLen)

          // Concatenate precWords, the boldened keyword and the succWords
          textWithBoldKeyword = precWords + keyword.bold() + succWords
        }

        return textWithBoldKeyword
      }
    </script>
{%  endblock %}

{% block content %}
    <h1> Search </h1>
<table class="dataTable" id="searchTable">
    <tr><td><b>Keywords</b></td><td><b>Transcript</b></td><td><b>Transcriber</b></td><td><b>Radius</b></td></tr>

    <tr>
        <td>
            <div id="search_form">
            <label for="searchBox"></label>
            <input type="text" id="searchBox" placeholder="">
            </div>
        </td>
        <td>
            <div id="doc_form">
                <label for="docBox"></label>
                <input list="docList" id="docBox" placeholder="">
                <datalist id="docList">
                </datalist>
            </div>
        </td>
        <td>
            <div id="transcriber_form">
                <label for="transcriberBox"></label>
                <input list="transcriberList" id="transcriberBox" placeholder="">
                <datalist id="transcriberList">
                </datalist>
            </div>
        </td>
        <td>
            <form>
                <label for="contextSlider"></label>
                <input type="range" id="contextSlider" name="contextSlider" min="3" max="40" value="6">
            </form>
        </td>
    </tr>
</table>

    <br>
    <div id="error_message"></div>

    <br>
    <table class="doctable" id="numMatchesTable">
    </table>
    <br>

    <br>
    <table class="doctable dataTable no-footer" id="resultsTable">
        <thead></thead>
        <tbody></tbody>
    </table>

    <p></p>

{% endblock %}



